<div id="graph"></div>
<script>

var graphData; // Declare globally to ensure it's accessible from HTML

document.addEventListener('DOMContentLoaded', async function() {
  const elementResizeDetector = elementResizeDetectorMaker();
  try {
      const apiBaseUrl = '{{ api_base_url }}';
      const userJson = '{{ user | tojson | safe }}';  
      //console.log(userJson)
      const userId = '{{ user.id | tojson | safe }}';
      const userAvatar = {{ user.avatar | tojson | safe }};
      console.log(userAvatar);
      const userName = '{{ user.username | tojson | safe }}';

      const followers = await fetchAllItems(userId, 'followers', apiBaseUrl); 
      const followings = await fetchAllItems(userId, 'following', apiBaseUrl);
      graphData = generateGraphData(userId, userName, userAvatar, followers, followings); 
      window.graph = initGraph(graphData);
      // Resize the graph when the window is resized
      elementResizeDetector.listenTo(document.getElementById('graph'), function(element) {
            var width = element.offsetWidth;
            window.graph.width(width);
      });
  } catch (error) {
      console.error('Initialization failed:', error); 
  }
});

async function fetchAllItems(userId, endpoint, apiBaseUrl) {
  let items = [];

  let url = `${apiBaseUrl}/${endpoint}?user_id=${userId}`;
  
  const response = await fetch(url);

  const data = await response.json();
  console.log(`Received data length: ${data.length}`); // Debugging output

  items = items.concat(data); // Add new items to the array

  return items; // Return all fetched items
}



function generateGraphData(userId, userName, userAvatar, followers, followings) {
    const uniqueUsers = new Map();

    // Helper function to add or update users in the map
    function addUser(user, type) {
        if (!uniqueUsers.has(user.id)) {
            uniqueUsers.set(user.id, {
                ...user,
                types: new Set([type]),
                followerCount: user.followers_count,
                followingCount: user.following_count
            });
        } else {
            uniqueUsers.get(user.id).types.add(type);
        }
    }

    // Add followers and followings to the map
    followers.forEach(follower => addUser(follower, 'follower'));
    followings.forEach(following => addUser(following, 'following'));

    // Convert map to array of nodes
    const nodes = Array.from(uniqueUsers.values()).map(user => ({
        id: user.id,
        username: user.username,
        type: Array.from(user.types).join('+'), // Combines types if both follower and following
        avatar: user.avatar,
        followerCount: user.followerCount,
        followingCount: user.followingCount
    }));

    // Add central user node
    nodes.unshift({
        id: userId,
        username: userName,
        type: 'user',
        avatar: userAvatar,
        followerCount: followers.length,
        followingCount: followings.length
    });

    // Create links for followers and followings
    const links = nodes.slice(1).map(node => ({
        source: userId,
        target: node.id
    }));

    return { nodes, links };
}

function initGraph(graphData) {
    const Graph = ForceGraph()(document.getElementById('graph'))
        .backgroundColor('#F5F5FF')
        .height(window.innerHeight - 60)
        .graphData(graphData)
        .nodeCanvasObject((node, ctx, globalScale) => {
          const label = node.username;
          const fontSize = 12 / globalScale;
          const baseImgSize = 28; // Base size for images
          // Dynamically adjust node size based on follower count
          const imgSize = baseImgSize + (Math.log(node.followerCount + 1) * 5); // Increase size logarithmically

          ctx.font = `${fontSize}px Sans-Serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          if (node.avatar && node.img) {
              ctx.drawImage(node.img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
          } else if (node.avatar && !node.img) {
              const img = new Image();
              img.src = node.avatar;
              img.onload = () => {
                  node.img = img; // Cache the image in the node
                  ctx.drawImage(img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
              };
          }
          
          ctx.fillStyle = (node.type === 'follower') ? 'red' : 'blue'; 
          ctx.fillText(label, node.x, node.y + imgSize / 2 + 5);
      })
      .onNodeClick(node => console.log(node));

    Graph.d3Force('charge', d3.forceManyBody().strength(-140));
    Graph.d3Force('link', d3.forceLink().distance(420));

    return Graph;  // Return the graph instance
}

window.filterNodes = function(filterType) {  // Declare globally to ensure it's accessible from HTML
    const filteredData = {
        nodes: graphData.nodes.filter(node => filterType === 'all' || node.type === filterType),
        links: graphData.links.filter(link => {
            const sourceVisible = filterType === 'all' || link.source.type === filterType;
            const targetVisible = filterType === 'all' || link.target.type === filterType;
            return sourceVisible && targetVisible;
        })
    };
    graph.graphData(filteredData);
}

</script>
