<div id="graph"></div>
<script>

    // This script is loaded when the graph page is opened
    // It initializes the graph with the user's followers and followings
    // and provides a function to filter nodes based on type

    var graphData;

    document.addEventListener('DOMContentLoaded', async function() {
    const elementResizeDetector = elementResizeDetectorMaker();
    try {

        const apiBaseUrl = '{{ api_base_url }}';
        const userJson = '{{ user | tojson | safe }}';  
        const userId = '{{ user.id | tojson | safe }}';
        const userAvatar = '{{ user.avatar }}';
        const userName = '{{ user.username | tojson | safe }}';

        // Fetch followers and followings
        const followers = await fetchAllItems(userId, 'followers', apiBaseUrl); 
        const followings = await fetchAllItems(userId, 'following', apiBaseUrl);
        // Generate graph data
        graphData = generateGraphData(userId, userName, userAvatar, followers, followings); 
        window.graph = initGraph(graphData);
        // Resize the graph when the window is resized
        elementResizeDetector.listenTo(document.getElementById('graph'), function(element) {
                var width = element.clientWidth;
                var height = element.clientHeight;
                window.graph.width(width);
                window.graph.height(height);
    });
    } catch (error) {
        console.error('Initialization failed:', error); 
    }
    });

    async function fetchAllItems(userId, endpoint, apiBaseUrl) {
    let items = [];

    let url = `${apiBaseUrl}/${endpoint}?user_id=${userId}`;
    
    const response = await fetch(url);

    const data = await response.json();
    console.log(`Received data length: ${data.length}`); // Debugging output

    items = items.concat(data); // Add new items to the array

    return items; // Return all fetched items
    }

    function generateGraphData(userId, userName, userAvatar, followers, followings) {

        const regex = /https?:\/\/([^/:]+)/; // Regex to extract domain from URL

        // Initialize user node with avatar and follower/following counts
        const nodes = [{
            id: userId,
            username: userName,
            type: 'user',
            avatar: userAvatar,
            followerCount: followers.length, // Assuming followers and followings are arrays
            followingCount: followings.length,
        }];
        
        // Generate nodes for followers with their own follower/following counts
        const followerNodes = followers.map(f => ({
            id: `follower-${f.id}`, 
            username: f.username, 
            type: 'follower', 
            avatar: f.avatar,
            followerCount: f.followers_count,
            followingCount: f.following_count,
            // Extract domain from URL
            instance: f.url.match(regex)
        }));

        // Generate nodes for followings with their own follower/following counts
        const followingNodes = followings.map(f => ({
            id: `following-${f.id}`,
            username: f.username, 
            type: 'following', 
            avatar: f.avatar,
            followerCount: f.followers_count,
            followingCount: f.following_count,
            // Extract domain from URL
            instance: f.url.match(f.url)
        }));
        
        nodes.push(...followerNodes, ...followingNodes);
        const links = followerNodes.map(f => ({ source: userId, target: f.id }))
                            .concat(followingNodes.map(f => ({ source: userId, target: f.id })));

        return { nodes, links };
    }

    function initGraph(graphData) {
        // Get the container element
        const container = document.getElementById('graph');
        // Initialize the graph
        const Graph = ForceGraph()(document.getElementById('graph'))
            .height(container.clientHeight)
            .graphData(graphData)
            .nodeAutoColorBy('type')
            .nodeCanvasObject((node, ctx, globalScale) => {
            const label = node.username;
            const fontSize = 12 / globalScale;
            const baseImgSize = 28; // Base size for images
            // Dynamically adjust node size based on follower count
            const imgSize = baseImgSize + (Math.log(node.followerCount + 1) * 7); // Increase size logarithmically

            ctx.font = `${fontSize}px Sans-Serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (node.avatar && node.img) {
                ctx.drawImage(node.img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
            } else if (node.avatar && !node.img) {
                const img = new Image();
                img.src = node.avatar;
                img.onload = () => {
                    node.img = img; // Cache the image in the node
                    ctx.drawImage(img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                };
            }
            
            ctx.fillStyle = (node.type === 'follower') ? 'red' : 'blue'; 
            ctx.fillText(label, node.x, node.y + imgSize / 2 + 5);
        })
        // Show node info on click
        .onNodeClick(node => console.log(node))
        // Paint the node pointer area with a circle
        .nodePointerAreaPaint((node, color, ctx) => {
            const imgSize = 28 + (Math.log(node.followerCount + 1) * 5); // Same calculation as in nodeCanvasObject
            ctx.fillStyle = color;  // Use the color parameter for hit detection painting
            ctx.beginPath();
            ctx.arc(node.x, node.y, imgSize / 2, 0, 2 * Math.PI, false);
            ctx.fill();
        });

        // Add forces to the graph
        Graph.d3Force('collide', d3.forceCollide().radius(30));
        Graph.d3Force('x', d3.forceX(container.clientWidth / 2).strength(0.1));
        Graph.d3Force('y', d3.forceY(container.clientHeight / 2).strength(0.1));
        Graph.d3Force('charge', d3.forceManyBody().strength(-140));
        Graph.d3Force('link', d3.forceLink().distance(420));
        Graph.d3Force('charge').distanceMax(200);


        return Graph;  // Return the graph instance
    }

    window.filterNodes = function(filterType) {
        const filteredData = {
            nodes: graphData.nodes.filter(node => filterType === 'all' || node.type === filterType || node.type === 'user'), // Keep user nodes visible
            links: graphData.links.filter(link => {
                const sourceVisible = filterType === 'all' || link.source.type === filterType || link.source.type === 'user';
                const targetVisible = filterType === 'all' || link.target.type === filterType || link.target.type === 'user';
                return sourceVisible && targetVisible;
            })
        };
        graph.graphData(filteredData); // Update the graph with filtered data
    }

</script>
