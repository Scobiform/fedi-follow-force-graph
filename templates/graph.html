<div id="graph"></div>
<script>

    // This script is loaded when the graph page is opened
    // It initializes the graph with the user's followers and followings
    // and provides a function to filter nodes based on type

    var graphData;

    document.addEventListener('DOMContentLoaded', async function() {
    const elementResizeDetector = elementResizeDetectorMaker();
    try {

        const apiBaseUrl = '{{ api_base_url }}';
        const userJson = '{{ user | tojson | safe }}';  
        const userId = '{{ user.id | tojson | safe }}';
        const userAvatar = '{{ user.avatar }}';
        const userName = '{{ user.username | tojson | safe }}';

        // Fetch followers and followings
        const followers = await fetchAllItems(userId, 'followers', apiBaseUrl); 
        const followings = await fetchAllItems(userId, 'following', apiBaseUrl);
        // Generate graph data
        graphData = generateGraphData(userId, userName, userAvatar, followers, followings);
        // Calculate the number of connections for each node
        calculateNodeConnections(graphData.nodes, graphData.links);
        window.graph = initGraph(graphData);
        // Resize the graph when the window is resized
        elementResizeDetector.listenTo(document.getElementById('graph'), function(element) {
                var width = element.clientWidth;
                var height = element.clientHeight;
                window.graph.width(width);
                window.graph.height(height);
    });
    } catch (error) {
        console.error('Initialization failed:', error); 
    }
    });

    async function fetchAllItems(userId, endpoint, apiBaseUrl) {
    let items = [];

    let url = `${apiBaseUrl}/${endpoint}?user_id=${userId}`;
    
    const response = await fetch(url);

    const data = await response.json();
    console.log(`Received data length: ${data.length}`); // Debugging output

    items = items.concat(data); // Add new items to the array

    return items; // Return all fetched items
    }

    function generateGraphData(userId, userName, userAvatar, followers, followings) {
        const regex = /https?:\/\/([^/:]+)/; // Regex to extract domain from URL

        // Initialize user node with avatar and follower/following counts
        const nodes = [{
            id: userId,
            username: userName,
            type: 'user',
            avatar: userAvatar,
            followerCount: followers.length, // Assuming followers and followings are arrays
            followingCount: followings.length,
        }];

        const instanceMap = new Map();

        // Function to create or get existing instance node
        function getInstanceNode(domain) {
            if (!instanceMap.has(domain)) {
                const instanceNode = {
                    id: `instance-${domain}`,
                    username: domain,
                    type: 'instance',
                    avatar: '', // Optional: a specific icon for instances
                    instance: domain
                };
                instanceMap.set(domain, instanceNode);
                nodes.push(instanceNode);
            }
            return instanceMap.get(domain);
        }

        // Generate nodes and links for followers
        const followerLinks = followers.map(f => {
            const domainMatch = f.url.match(regex);
            const domain = domainMatch ? domainMatch[1] : "unknown";
            const followerNode = {
                id: `follower-${f.id}`,
                username: f.username,
                type: 'follower',
                avatar: f.avatar,
                followerCount: f.followers_count,
                followingCount: f.following_count,
                instance: domain
            };
            nodes.push(followerNode);

            return { source: userId, target: followerNode.id, type: 'follow' };
        });

        // Generate nodes and links for followings
        const followingLinks = followings.map(f => {
            const domainMatch = f.url.match(regex);
            const domain = domainMatch ? domainMatch[1] : "unknown";
            const followingNode = {
                id: `following-${f.id}`,
                username: f.username,
                type: 'following',
                avatar: f.avatar,
                followerCount: f.followers_count,
                followingCount: f.following_count,
                instance: domain
            };
            nodes.push(followingNode);

            return { source: userId, target: followingNode.id, type: 'follow' };
        });

        // Generate instance links
        const instanceLinks = nodes.filter(n => n.type !== 'user').map(n => ({
            source: getInstanceNode(n.instance).id,
            target: n.id,
            type: 'instance'
        }));

        const links = followerLinks.concat(followingLinks, instanceLinks);

        console.log('Generated graph data:', { nodes, links }); // Debugging output
        return { nodes, links };
    }

    // Function to calculate the number of connections for each node
    function calculateNodeConnections(nodes, links) {
        const connectionCount = new Map();

        links.forEach(link => {
            const sourceId = (typeof link.source === 'object') ? link.source.id : link.source;
            const targetId = (typeof link.target === 'object') ? link.target.id : link.target;

            connectionCount.set(sourceId, (connectionCount.get(sourceId) || 0) + 1);
            connectionCount.set(targetId, (connectionCount.get(targetId) || 0) + 1);
        });

        nodes.forEach(node => {
            node.connectionCount = connectionCount.get(node.id) || 0;
        });
    }

    function initGraph(graphData) {
        // Get the container element
        const container = document.getElementById('graph');
        // Initialize the graph
        const Graph = ForceGraph()(document.getElementById('graph'))
            .height(container.clientHeight)
            .graphData(graphData)
            .nodeAutoColorBy('type')
            .linkColor(link => {
                if (link.type === 'instance') return 'green';
                return 'rgba(0,0,0,0.5)';
            })
            .linkWidth(link => link.type === 'instance' ? 2 : 1) 
            .nodeCanvasObject((node, ctx, globalScale) => {
                const label = node.username;
                const fontSize = 12 / globalScale;
                const baseImgSize = 28;
                let imgSize = baseImgSize + (Math.log(node.followerCount + 1) * 7); // Increase size logarithmically

                ctx.font = `${fontSize}px Sans-Serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Differentiate the appearance based on node type
                if (node.type === 'instance') {
                    imgSize = 30 + 3 * Math.sqrt(node.connectionCount);
                    ctx.fillStyle = 'green';
                    ctx.beginPath();
                    ctx.rect(node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize); // Draw a square
                    ctx.fill();
                    ctx.fillStyle = 'white'; // Text color for instance nodes
                    ctx.fillText(label, node.x, node.y);
                } else {
                    if (node.avatar && node.img) {
                        ctx.drawImage(node.img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                    } else if (node.avatar && !node.img) {
                        const img = new Image();
                        img.src = node.avatar;
                        img.onload = () => {
                            node.img = img; // Cache the image in the node
                            ctx.drawImage(img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                        };
                    }
                    
                    ctx.fillStyle = (node.type === 'follower') ? 'red' : 'blue'; 
                    ctx.fillText(label, node.x, node.y + imgSize / 2 + 5);
                }
            })
        // Show node info on click
        .onNodeClick(node => console.log(node))
        // Paint the node pointer area with a circle
        .nodePointerAreaPaint((node, color, ctx) => {
            const imgSize = node.type === 'instance' ? 50 : 28 + (Math.log(node.followerCount + 1) * 5);
            ctx.fillStyle = color;
            if (node.type === 'instance') {
                ctx.beginPath();
                ctx.rect(node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.arc(node.x, node.y, imgSize / 2, 0, 2 * Math.PI, false);
                ctx.fill();
            }
        });

        // Add forces to the graph
        Graph.d3Force('collide', d3.forceCollide().radius(140)); 
        Graph.d3Force('charge', d3.forceManyBody().strength(-630));
        Graph.d3Force('link', d3.forceLink().distance(2000).strength(0.05)); 
        Graph.d3Force('charge').distanceMax(42000); 

        return Graph;
    }

    // Resize the graph when the window is resized
    window.addEventListener('resize', () => {
        const width = container.clientWidth;
        const height = container.clientHeight;
        Graph.width(width).height(height);
        Graph.d3Force('x', d3.forceX(width / 2).strength(0.05));
        Graph.d3Force('y', d3.forceY(height / 2).strength(0.05));
    });

    // Function to filter nodes based on type    
    window.filterNodes = function(filterType) {
        // This will hold the IDs of nodes that should be visible based on the filtering criteria.
        const visibleNodes = new Set();

        // Add directly visible nodes based on filter type.
        graphData.nodes.forEach(node => {
            if (filterType === 'all' || node.type === filterType || node.type === 'user') {
                visibleNodes.add(node.id);
            }
        });

        // Filter links based on visible nodes.
        const filteredLinks = graphData.links.filter(link => {
            let sourceId = (typeof link.source === 'object') ? link.source.id : link.source;
            let targetId = (typeof link.target === 'object') ? link.target.id : link.target;
            return visibleNodes.has(sourceId) && visibleNodes.has(targetId);
        });

        // Ensure instance nodes linked to any visible node are also shown
        filteredLinks.forEach(link => {
            let sourceId = (typeof link.source === 'object') ? link.source.id : link.source;
            let targetId = (typeof link.target === 'object') ? link.target.id : link.target;
            visibleNodes.add(sourceId);
            visibleNodes.add(targetId);
        });

        // Prepare the filtered data for nodes and links.
        const filteredData = {
            nodes: graphData.nodes.filter(node => visibleNodes.has(node.id)),
            links: filteredLinks
        };

        // Update the graph with the filtered data.
        graph.graphData(filteredData);
    }
</script>
