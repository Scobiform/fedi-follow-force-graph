<div id="graph"></div>
<script>
document.addEventListener('DOMContentLoaded', async function() {
    try {
        const apiBaseUrl = '{{ api_base_url }}';
        const accessToken = sessionStorage.getItem('accessToken');
        const userJson = '{{ user | tojson | safe }}';  
        //console.log(userJson)
        const userId = '{{ user.id | tojson | safe }}';
        const userAvatar = '{{ user.avatar | tojson | safe }}';
        const userName = '{{ user.username | tojson | safe }}';

        const followers = await fetchAllItems(userId, 'followers', apiBaseUrl, accessToken); 
        const followings = await fetchAllItems(userId, 'following', apiBaseUrl, accessToken);
        const graphData = generateGraphData(userId, userName, userAvatar, followers, followings); 
        window.graph = initGraph(graphData); 
    } catch (error) {
        console.error('Initialization failed:', error); 
    }
});

async function fetchAllItems(userId, endpoint, apiBaseUrl, accessToken) {
  let items = [];

  let url = `${apiBaseUrl}/${endpoint}?user_id=${userId}`;
  
  const response = await fetch(url, {
      headers: { 'Authorization': `Bearer ${accessToken}` }
  });
  
  const data = await response.json();
  console.log(`Received data length: ${data.length}`); // Debugging output

  items = items.concat(data); // Add new items to the array

  return items; // Return all fetched items
}



function generateGraphData(userId, userName, userAvatar, followers, followings) {
    const nodes = [{ id: userId, username: userName, type: 'user', avatar: userAvatar }];
    const followerNodes = followers.map(f => ({ id: f.id, username: f.username, type: 'follower', avatar: f.avatar }));
    const followingNodes = followings.map(f => ({ id: f.id, username: f.username, type: 'following', avatar: f.avatar }));
    nodes.push(...followerNodes, ...followingNodes);
    const links = followerNodes.map(f => ({ source: userId, target: f.id }))
                        .concat(followingNodes.map(f => ({ source: userId, target: f.id })));
    return { nodes, links };
}

function initGraph(graphData) {
    const Graph = ForceGraph()(document.getElementById('graph'))
        .backgroundColor('#F5F5FF')
        .height(window.innerHeight - 60)
        .graphData(graphData)
        .nodeCanvasObject((node, ctx, globalScale) => {
            const label = node.username;
            const fontSize = 12 / globalScale;
            const imgSize = 28;
            ctx.font = `${fontSize}px Sans-Serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (node.avatar && node.img) {
                ctx.drawImage(node.img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
            } else if (node.avatar && !node.img) {
                const img = new Image();
                img.src = node.avatar;
                img.onload = () => {
                    node.img = img;
                    ctx.drawImage(img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                };
            }
            ctx.fillStyle = (node.type === 'follower') ? 'red' : 'blue'; 
            ctx.fillText(label, node.x, node.y + imgSize / 2 + 5);
        })
        .onNodeClick(node => console.log(node));

    Graph.d3Force('charge', d3.forceManyBody().strength(-120));
    Graph.d3Force('link', d3.forceLink().distance(140));

    return Graph;  // Return the graph instance
}

window.filterNodes = function(filterType) {  // Declare globally to ensure it's accessible from HTML
    const filteredData = {
        nodes: graphData.nodes.filter(node => filterType === 'all' || node.type === filterType),
        links: graphData.links.filter(link => {
            const sourceVisible = filterType === 'all' || link.source.type === filterType;
            const targetVisible = filterType === 'all' || link.target.type === filterType;
            return sourceVisible && targetVisible;
        })
    };
    graph.graphData(filteredData);
}
</script>
