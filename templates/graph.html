<div id="graph"></div>
<script>

    // This script is loaded when the graph page is opened
    // It initializes the graph with the user's followers and followings
    // and provides a function to filter nodes based on type

    var graphData;

    document.addEventListener('DOMContentLoaded', async function() {
    const elementResizeDetector = elementResizeDetectorMaker();
    try {

        const apiBaseUrl = '{{ api_base_url }}';
        const userJson = '{{ user | tojson | safe }}';  
        const userId = '{{ user.id | tojson | safe }}';
        const userAvatar = '{{ user.avatar }}';
        const userName = '{{ user.username | tojson | safe }}';

        // Fetch followers and followings
        const followers = await fetchAllItems(userId, 'followers', apiBaseUrl); 
        const followings = await fetchAllItems(userId, 'following', apiBaseUrl);
        // Generate graph data
        graphData = generateGraphData(userId, userName, userAvatar, followers, followings); 
        window.graph = initGraph(graphData);
        // Resize the graph when the window is resized
        elementResizeDetector.listenTo(document.getElementById('graph'), function(element) {
                var width = element.clientWidth;
                var height = element.clientHeight;
                window.graph.width(width);
                window.graph.height(height);
    });
    } catch (error) {
        console.error('Initialization failed:', error); 
    }
    });

    async function fetchAllItems(userId, endpoint, apiBaseUrl) {
    let items = [];

    let url = `${apiBaseUrl}/${endpoint}?user_id=${userId}`;
    
    const response = await fetch(url);

    const data = await response.json();
    console.log(`Received data length: ${data.length}`); // Debugging output

    items = items.concat(data); // Add new items to the array

    return items; // Return all fetched items
    }

    function generateGraphData(userId, userName, userAvatar, followers, followings) {
        const regex = /https?:\/\/([^/:]+)/; // Regex to extract domain from URL

        // Initialize user node with avatar and follower/following counts
        const nodes = [{
            id: userId,
            username: userName,
            type: 'user',
            avatar: userAvatar,
            followerCount: followers.length, // Assuming followers and followings are arrays
            followingCount: followings.length,
        }];

        const instanceMap = new Map();

        // Function to create or get existing instance node
        function getInstanceNode(domain) {
            if (!instanceMap.has(domain)) {
                const instanceNode = {
                    id: `instance-${domain}`,
                    username: domain,
                    type: 'instance',
                    avatar: '', // Optional: a specific icon for instances
                    instance: domain
                };
                instanceMap.set(domain, instanceNode);
                nodes.push(instanceNode);
            }
            return instanceMap.get(domain);
        }

        // Generate nodes and links for followers
        const followerLinks = followers.map(f => {
            const domainMatch = f.url.match(regex);
            const domain = domainMatch ? domainMatch[1] : "unknown";
            const followerNode = {
                id: `follower-${f.id}`,
                username: f.username,
                type: 'follower',
                avatar: f.avatar,
                followerCount: f.followers_count,
                followingCount: f.following_count,
                instance: domain
            };
            nodes.push(followerNode);

            return { source: userId, target: followerNode.id, type: 'follow' };
        });

        // Generate nodes and links for followings
        const followingLinks = followings.map(f => {
            const domainMatch = f.url.match(regex);
            const domain = domainMatch ? domainMatch[1] : "unknown";
            const followingNode = {
                id: `following-${f.id}`,
                username: f.username,
                type: 'following',
                avatar: f.avatar,
                followerCount: f.followers_count,
                followingCount: f.following_count,
                instance: domain
            };
            nodes.push(followingNode);

            return { source: userId, target: followingNode.id, type: 'follow' };
        });

        // Generate instance links
        const instanceLinks = nodes.filter(n => n.type !== 'user').map(n => ({
            source: getInstanceNode(n.instance).id,
            target: n.id,
            type: 'instance'
        }));

        const links = followerLinks.concat(followingLinks, instanceLinks);

        console.log('Generated graph data:', { nodes, links }); // Debugging output
        return { nodes, links };
    }

    function initGraph(graphData) {
        // Get the container element
        const container = document.getElementById('graph');
        // Initialize the graph
        const Graph = ForceGraph()(document.getElementById('graph'))
            .height(container.clientHeight)
            .graphData(graphData)
            .nodeAutoColorBy('type')
            .linkColor(link => {
                if (link.type === 'instance') return 'green';
                return 'rgba(0,0,0,0.5)';
            })
            .linkWidth(link => link.type === 'instance' ? 2 : 1) 
            .nodeCanvasObject((node, ctx, globalScale) => {
                const label = node.username;
                const fontSize = 12 / globalScale;
                const baseImgSize = 28;
                let imgSize = baseImgSize + (Math.log(node.followerCount + 1) * 7); // Increase size logarithmically

                ctx.font = `${fontSize}px Sans-Serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Differentiate the appearance based on node type
                if (node.type === 'instance') {
                    imgSize = 50; // Constant size for instance nodes
                    ctx.fillStyle = 'green'; // Distinct color for instance nodes
                    ctx.beginPath();
                    ctx.rect(node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize); // Draw a square
                    ctx.fill();
                    ctx.fillStyle = 'white'; // Text color for instance nodes
                    ctx.fillText(label, node.x, node.y);
                } else {
                    if (node.avatar && node.img) {
                        ctx.drawImage(node.img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                    } else if (node.avatar && !node.img) {
                        const img = new Image();
                        img.src = node.avatar;
                        img.onload = () => {
                            node.img = img; // Cache the image in the node
                            ctx.drawImage(img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                        };
                    }
                    
                    ctx.fillStyle = (node.type === 'follower') ? 'red' : 'blue'; 
                    ctx.fillText(label, node.x, node.y + imgSize / 2 + 5);
                }
            })
        // Show node info on click
        .onNodeClick(node => console.log(node))
        // Paint the node pointer area with a circle
        .nodePointerAreaPaint((node, color, ctx) => {
            const imgSize = node.type === 'instance' ? 50 : 28 + (Math.log(node.followerCount + 1) * 5);
            ctx.fillStyle = color;
            if (node.type === 'instance') {
                ctx.beginPath();
                ctx.rect(node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.arc(node.x, node.y, imgSize / 2, 0, 2 * Math.PI, false);
                ctx.fill();
            }
        });

        // Add forces to the graph
        Graph.d3Force('collide', d3.forceCollide().radius(420)); 
        Graph.d3Force('charge', d3.forceManyBody().strength(-420));
        Graph.d3Force('link', d3.forceLink().distance(500).strength(0.1)); 
        Graph.d3Force('charge').distanceMax(21000); 

        return Graph;  // Return the graph instance
    }

    // Resize the graph when the window is resized
    window.addEventListener('resize', () => {
        const width = container.clientWidth;
        const height = container.clientHeight;
        Graph.width(width).height(height);
        Graph.d3Force('x', d3.forceX(width / 2).strength(0.05));
        Graph.d3Force('y', d3.forceY(height / 2).strength(0.05));
    });

    // Function to filter nodes based on type    
    window.filterNodes = function(filterType) {
    // This will hold the IDs of nodes that should be visible based on the filtering criteria.
    const visibleNodes = new Set();

    // Add directly visible nodes based on filter type.
    graphData.nodes.forEach(node => {
        if (filterType === 'all' || node.type === filterType || node.type === 'user') {
            visibleNodes.add(node.id);
        }
    });

    // Since links in many graph libraries might reference the actual node objects after initialization,
    // we need to ensure that the source and target ids are used correctly.
    // Assuming link.source and link.target may be objects after simulation starts.
    const filteredLinks = graphData.links.filter(link => {
        let sourceId = (typeof link.source === 'object') ? link.source.id : link.source;
        let targetId = (typeof link.target === 'object') ? link.target.id : link.target;
        return visibleNodes.has(sourceId) && visibleNodes.has(targetId);
    });

    // Ensure instance nodes linked to any visible node are also shown
    filteredLinks.forEach(link => {
        let sourceId = (typeof link.source === 'object') ? link.source.id : link.source;
        let targetId = (typeof link.target === 'object') ? link.target.id : link.target;
        visibleNodes.add(sourceId);
        visibleNodes.add(targetId);
    });

    // Prepare the filtered data for nodes and links.
    const filteredData = {
        nodes: graphData.nodes.filter(node => visibleNodes.has(node.id)),
        links: filteredLinks
    };

    // Update the graph with the filtered data.
    graph.graphData(filteredData);
}
</script>
