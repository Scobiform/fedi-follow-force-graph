<div id="graph"></div>
<script>
document.addEventListener('DOMContentLoaded', async function() {
    try {
        const apiBaseUrl = '{{ api_base_url }}';
        const accessToken = sessionStorage.getItem('accessToken');
        const user = JSON.parse('{{ user_json | safe }}');

        const followers = await fetchAllItems(user.id, 'followers'); 
        const followings = await fetchAllItems(user.id, 'following');
        const graphData = generateGraphData(user, followers, followings); // Generate graph data
        window.graph = initGraph(graphData); // Initialize the graph and store it globally
    } catch (error) {
        console.error('Initialization failed:', error); // Log errors to the console
    }
});

async function fetchAllItems(userId, endpoint) {
    let items = [];
    let maxId = null;
    do {
        const response = await fetch(`${apiBaseUrl}/${endpoint}/${userId}?limit=500&max_id=${maxId}`, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        const data = await response.json();
        items = items.concat(data);
        maxId = data.length > 0 ? data[data.length - 1].id : null;
    } while (maxId != null);
    return items;
}

function generateGraphData(user, followers, followings) {
    const nodes = [{ id: user.id, username: user.username, type: 'user', avatar: user.avatar }];
    const followerNodes = followers.map(f => ({ id: f.id, username: f.username, type: 'follower', avatar: f.avatar }));
    const followingNodes = followings.map(f => ({ id: f.id, username: f.username, type: 'following', avatar: f.avatar }));
    nodes.push(...followerNodes, ...followingNodes);
    const links = followerNodes.map(f => ({ source: user.id, target: f.id }))
                        .concat(followingNodes.map(f => ({ source: user.id, target: f.id })));
    return { nodes, links };
}

function initGraph(graphData) {
    const Graph = ForceGraph()(document.getElementById('graph'))
        .backgroundColor('#F5F5FF')
        .height(window.innerHeight - 60)
        .graphData(graphData)
        .nodeCanvasObject((node, ctx, globalScale) => {
            const label = node.username;
            const fontSize = 12 / globalScale;
            const imgSize = 28;
            ctx.font = `${fontSize}px Sans-Serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (node.avatar && node.img) {
                ctx.drawImage(node.img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
            } else if (node.avatar && !node.img) {
                const img = new Image();
                img.src = node.avatar;
                img.onload = () => {
                    node.img = img;
                    ctx.drawImage(img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
                };
            }
            ctx.fillStyle = (node.type === 'follower') ? 'red' : 'blue'; 
            ctx.fillText(label, node.x, node.y + imgSize / 2 + 5);
        })
        .onNodeClick(node => console.log(node));

    Graph.d3Force('charge', d3.forceManyBody().strength(-120));
    Graph.d3Force('link', d3.forceLink().distance(140));

    return Graph;  // Return the graph instance
}

window.filterNodes = function(filterType) {  // Declare globally to ensure it's accessible from HTML
    const filteredData = {
        nodes: graphData.nodes.filter(node => filterType === 'all' || node.type === filterType),
        links: graphData.links.filter(link => {
            const sourceVisible = filterType === 'all' || link.source.type === filterType;
            const targetVisible = filterType === 'all' || link.target.type === filterType;
            return sourceVisible && targetVisible;
        })
    };
    graph.graphData(filteredData);
}
</script>
