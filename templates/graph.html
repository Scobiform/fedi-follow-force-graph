<div id="graph"></div>
<script>

var graphData; // Declare globally to ensure it's accessible from HTML

document.addEventListener('DOMContentLoaded', async function() {
  const elementResizeDetector = elementResizeDetectorMaker();
  try {
      const apiBaseUrl = '{{ api_base_url }}';
      const userJson = '{{ user | tojson | safe }}';  
      //console.log(userJson)
      const userId = '{{ user.id | tojson | safe }}';
      const userAvatar = {{ user.avatar | tojson | safe }};
      console.log(userAvatar);
      const userName = '{{ user.username | tojson | safe }}';

      const followers = await fetchAllItems(userId, 'followers', apiBaseUrl); 
      const followings = await fetchAllItems(userId, 'following', apiBaseUrl);
      graphData = generateGraphData(userId, userName, userAvatar, followers, followings); 
      window.graph = initGraph(graphData);
      // Resize the graph when the window is resized
      elementResizeDetector.listenTo(document.getElementById('graph'), function(element) {
            var width = element.offsetWidth;
            window.graph.width(width);
      });
  } catch (error) {
      console.error('Initialization failed:', error); 
  }
});

async function fetchAllItems(userId, endpoint, apiBaseUrl) {
  let items = [];

  let url = `${apiBaseUrl}/${endpoint}?user_id=${userId}`;
  
  const response = await fetch(url);

  const data = await response.json();
  console.log(`Received data length: ${data.length}`); // Debugging output

  items = items.concat(data); // Add new items to the array

  return items; // Return all fetched items
}



function generateGraphData(userId, userName, userAvatar, followers, followings) {
    const nodes = [{ id: userId, username: userName, type: 'user', avatar: userAvatar }];
    
    // Generate nodes for followers with their own follower/following counts
    const followerNodes = followers.map(f => ({
        id: f.id, 
        username: f.username, 
        type: 'follower', 
        avatar: f.avatar,
        followerCount: f.followers_count,
        followingCount: f.following_count
    }));

    // Generate nodes for followings with their own follower/following counts
    const followingNodes = followings.map(f => ({
        id: f.id, 
        username: f.username, 
        type: 'following', 
        avatar: f.avatar,
        followerCount: f.followers_count,
        followingCount: f.following_count
    }));
    
    nodes.push(...followerNodes, ...followingNodes);
    const links = followerNodes.map(f => ({ source: userId, target: f.id }))
                        .concat(followingNodes.map(f => ({ source: userId, target: f.id })));

    return { nodes, links };
}

function initGraph(graphData) {
    const Graph = ForceGraph()(document.getElementById('graph'))
        .backgroundColor('#F5F5FF')
        .height(window.innerHeight - 60)
        .graphData(graphData)
        .nodeCanvasObject((node, ctx, globalScale) => {
          const label = node.username;
          const fontSize = 12 / globalScale;
          const baseImgSize = 28; // Base size for images
          // Dynamically adjust node size based on follower count
          const imgSize = baseImgSize + (Math.log(node.followerCount + 1) * 5); // Increase size logarithmically

          ctx.font = `${fontSize}px Sans-Serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          if (node.avatar && node.img) {
              ctx.drawImage(node.img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
          } else if (node.avatar && !node.img) {
              const img = new Image();
              img.src = node.avatar;
              img.onload = () => {
                  node.img = img; // Cache the image in the node
                  ctx.drawImage(img, node.x - imgSize / 2, node.y - imgSize / 2, imgSize, imgSize);
              };
          }
          
          ctx.fillStyle = (node.type === 'follower') ? 'red' : 'blue'; 
          ctx.fillText(label, node.x, node.y + imgSize / 2 + 5);
      })
      .onNodeClick(node => console.log(node));

    Graph.d3Force('charge', d3.forceManyBody().strength(-140));
    Graph.d3Force('link', d3.forceLink().distance(420));

    return Graph;  // Return the graph instance
}

window.filterNodes = function(filterType) {  // Declare globally to ensure it's accessible from HTML
    const filteredData = {
        nodes: graphData.nodes.filter(node => filterType === 'all' || node.type === filterType),
        links: graphData.links.filter(link => {
            const sourceVisible = filterType === 'all' || link.source.type === filterType;
            const targetVisible = filterType === 'all' || link.target.type === filterType;
            return sourceVisible && targetVisible;
        })
    };
    graph.graphData(filteredData);
}

</script>
